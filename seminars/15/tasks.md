## Задания к семинару №15

**Примечание 1**: Для всех заданий рекомендуется написать модульные тесты.

**Примечание 2**: Постарайтесь использовать мнемонику PECS для всех параметров, где это возможно.

1. Реализуйте метод `filter`, принимающий список некоторого типа и функцию-предикат (`Predicate`). \
   Функция должна вернуть новый список, который состоит только из элементов, удовлетворяющих предикату. \
   Проверьте эту функцию, передав ей в качестве второго аргумента:
   1. Лямбда-выражение
   2. Анонимный класс
   3. Ссылку на метод
2. Реализуйте метод `map`, принимающий список некоторого типа и функцию-отображение от одного параметра (`Function`). \
   Функция-отображение переводит элементы списка в новые значения (например, `str -> Integer.parseInt(str)` переведёт список строк в список чисел). \
   Из функции должен возвращаться новый список. \
   Проверьте эту функцию, передав ей в качестве второго аргумента:
   1. Лямбда-выражение
   2. Анонимный класс
   3. Ссылку на метод
3. Реализуйте метод `findFirst`, принимающий список некоторого типа и функцию-предикат (`Predicate`). \
   Функция должна вернуть первый элемент списка, удовлетворяющий предикату. \
   Проверьте эту функцию, передав ей в качестве второго аргумента:
   1. Лямбда-выражение
   2. Анонимный класс
   3. Ссылку на метод
4. Реализуйте метод `sorted`, принимающий список некоторого типа и функцию-компаратор (`Comparator`). \
   Функция должна вернуть новый список, отсортированный по заданному компаратору. \
   Проверьте эту функцию, передав ей в качестве второго аргумента:
   1. Лямбда-выражение
   2. Анонимный класс
   3. Ссылку на метод
5. Реализуйте метод `forEach`, принимающий список некоторого типа и функцию от одного параметра без возвращаемого значения (`Consumer`). \
   Функция должна выполнить действие на каждом элементе списка. \
   Проверьте эту функцию, передав ей в качестве второго аргумента:
   1. Лямбда-выражение
   2. Анонимный класс
   3. Ссылку на метод
6. Реализуйте метод `reduce`, принимающий список некоторого типа, начальное значение и функцию свёртки от двух параметров (`BiFunction`). \
   Функция должна реализовывать операцию свёртки списка и возвращать результат. \
   Пример: вызов `reduce([1, 2, 3], init, (acc, elem) -> acc + elem)` должен быть эквивалентен `(((init + 1) + 2) + 3)`. \
   То есть, функция `reduce` постепенно слева направо применяет переданный ей оператор к текущему результату и очередному элементу (в качестве левого аргумента самой первой операции используется начальное значение). \
   Также это можно представить как постепенное 'добавление' очередного элемента к `init`:
   1. `reduce([1, 2, 3], init, (acc, elem) -> acc + elem)`
   2. `reduce([2, 3], init + 1, (acc, elem) -> acc + elem)` (первый элемент списка добавился к `init`)
   3. `reduce([3], (init + 1) + 2, (acc, elem) -> acc + elem)` (второй элемент списка добавился к `init`)
   4. `reduce([], ((init + 1) + 2) + 3, (acc, elem) -> acc + elem)` (третий элемент списка добавился к `init`)
   5. Результат: `((init + 1) + 2) + 3` (для пустого списка делать ничего не нужно)

   Проверьте эту функцию, передав ей в качестве второго аргумента:
   1. Лямбда-выражение
   2. Анонимный класс
   3. Ссылку на метод
7. Функция свёртки `reduce` позволяет делать огромное количество операций над списками. \
   Например, `reduce(list, 0, (a, b) -> a + b)` считает сумму списка, а `reduce(list, Integer.MIN_VALUE, (a, b) -> Math.max(a, b))` считает максимум в списке. \
   Реализуйте следующие операции при помощи вызова `reduce` с правильными аргументами:
   1. Перевод списка символов в строку (`["a", "b", "c"]` -> `"abc"`).
   2. Перевод списка строк в одну строку через разделитель (`["a", "b", "c"]` -> `"a, b, c"`).
   3. Функцию `filter` из предыдущего задания.
   4. Функцию `map` из предыдущего задания.
