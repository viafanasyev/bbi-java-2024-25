## Задания к семинару №14

**Примечание**: Для всех заданий рекомендуется написать модульные тесты.

1. Реализуйте метод, который принимает список некоторого типа и элемент такого же типа. \
   Метод должен найти индекс первого элемента списка, который строго больше второго параметра. \
   Подсказка: вам понадобится интерфейс `Comparable`.
2. Реализуйте метод, который принимает список некоторого типа и два индекса `begin` и `end`. \
   Метод должен найти индекс максимального элемента в интервале `[begin; end)`. \
   Подсказка: вам понадобится интерфейс `Comparable`.
3. Реализуйте метод, принимающий список произвольных элементов, и сортирующий этот список (алгоритм сортировки можно выбрать любой). \
   Подсказка: вам понадобится интерфейс `Comparable`. \
   Сравните результат своей сортировки с методом `Collections.sort` стандартной библиотеки.
4. Реализуйте класс `Employee` - сотрудник. У каждого сотрудника должны быть имя и зарплата. \
   Реализуйте для данного класса интерфейс `Comparable`, чтобы сотрудников можно было сравнивать по именам (в лексикографическом порядке). \
   Примените сортировку из предыдущего задания к списку сотрудников.
5. Реализуйте класс `Employee` и его наследников `Manager` и `Director`.  У каждого сотрудника должны быть имя и зарплата. \
   При помощи wildcards реализуйте следующие методы:
   1. Метод `averageSalary`, принимающий список из произвольных сотрудников и возвращающий их среднюю зарплату.
   2. Метод `maxSalary`, принимающий список из произвольных сотрудников и возвращающий сотрудника с максимальной зарплатой.
   3. Метод `copyInReverseOrder`, принимающий список из произвольных сотрудников и второй список любых элементов. Метод должен добавить элементы первого списка во второй список, но в обратном порядке.
   4. Метод `copyAsManager`, принимающий два списка из произвольных сотрудников. Метод должен создать на основе элементов первого списка менеджеров с такой же зарплатой и именем, и добавить получившихся менеджеров во второй список.
   5. Метод `mapByName`, принимающий список из произвольных сотрудников и `Map`, отображающий имя сотрудника в него самого. Метод должен добавить в `Map` всех сотрудников из списка.